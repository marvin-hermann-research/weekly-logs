# Weekly Log â€“ 2025-08-10

## Summary of Activities

### 05.08
- While further documenting `py_trees_ros`, learned that the `tick_tock` method not only spins the tree nodes but also internally calls `rclpy.spin()`, thereby spinning the entire ROS2 system  
- **Conclusion:** the executor should **not** call `spin()` again externally  
- As a result, **all nodes** â€“ even non-tree nodes â€“ must be added to the treeâ€™s internal executor so they are spun alongside the behavior tree (without being part of the treeâ€™s execution flow)  
- Completed the `Application` class, pushed to `main`, and merged  
- Closed the Git issue for creating the `Application` class  
- Updated the *Entry Point* section:  
  - Learned that the `Application` class can be registered directly as an entry point in `setup.py`  
  - This allows launching via `ros2 run` instead of using a conventional Python `main` entry point  

### 06.08
- Added simple status logging to the project  
- Updated the master document with a logging section:  
  - Learned that when combining `py_trees` and ROS2, logging should **always** be handled via ROS2  
  - Best practice: pass a ROS2 logger into `py_trees` components  
- Began executing and testing the code (debugging phase)  
  - Learned that `rclpy.init()` must **always** be the very first method executed in a ROS2 system  
  - If omitted or delayed, ROS2 will not start and nodes cannot be initialized  

### 07.08
- Continued debugging and updated the `ros_masterpost.md` accordingly:  
  - **YAML path issue:** relative paths cannot be used since the project runs from the workspaceâ€™s `install` directory  
    - **Solution:** use `ament_index_python.packages.get_package_share_directory` to retrieve the correct package path  
  - **Blackboard writer crash:** registering a blackboard key as `WRITER` without immediately initializing its value (`True`/`False`) caused runtime errors  
    - **Solution:** initialize values directly after registration  
- After fixing both issues, achieved the **first running draft** of the system ðŸŽ‰  

### 08.08
- Tested project functionality with:  
  - Behavior tree visualization  
  - Topic publishing checks  
- Found that the `py_trees` viewer did not work:  
  - **Root cause:** forgot to add the tree node itself to the executor (even though the tree is also treated as a node in ROS2)  
  - **Fix:** Added it and updated the masterpost accordingly  
- Conducted a second round of research on ROS2 action nodes and action servers:  
  - Currently not using them in the project, but clarified when and why they might be applicable in the future  

---

## Key Insights

- The `tick_tock` method in `py_trees_ros` simplifies spinning but requires **all relevant nodes** to be registered in the treeâ€™s executor to function properly  
- ROS2 logging should be used universally for consistency, even within `py_trees` components  
- Path handling in ROS2 must consider the runtime context (`install` directory), making `ament_index_python` utilities essential for locating package resources  
- Early initialization of critical components (e.g., `rclpy.init()`, blackboard keys) is crucial to avoid silent startup failures  

---

## Challenges & Fixes

- **Duplicate spinning via executor and `tick_tock`**  
  âœ” **Fix:** Removed manual `spin()` calls and ensured all nodes are registered with the tree executor  

- **YAML resource loading failure**  
  âœ” **Fix:** Replaced relative paths with `get_package_share_directory` to resolve files from the installed package location  

- **Blackboard writer crash due to uninitialized values**  
  âœ” **Fix:** Initialize blackboard keys immediately after registration  

- **Behavior tree viewer not functioning**  
  âœ” **Fix:** Added the tree node itself to the executor, ensuring visualization compatibility  

---

## Next Steps

- Continue verifying full project functionality via visualization and topic inspection  
- Investigate potential future use cases for ROS2 action nodes within the architecture  
- Refine and expand the `ros_masterpost.md` with clearer executor usage patterns and resource path handling best practices  
- Begin preliminary integration tests with simulated or real sensor/actuator inputs  
- Evaluate performance and stability under continuous execution conditions  
